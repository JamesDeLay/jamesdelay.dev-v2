---
title: 'Developing & Deploying with Docker & React'
excerpt: "A recipe for 'dockerizing' a React application for both development & production using nginx as a web server."
coverImage: '/assets/articles/react-docker.png'
date: '2022-09-30'
---

## Hello, hello, hello! 

Today, we'll `dockerize` a React/Flask application for development with an emphasis on developer experience. 

## What is Docker?

> Docker takes away repetitive, mundane configuration tasks and is used throughout the development lifecycle for fast, easy and portable application development...Dockerâ€™s comprehensive end to end platform includes UIs, CLIs, APIs and security that are engineered to work together across the entire application delivery lifecycle.
<sub>Docker Documentation</sub>

Docker attempts to solve the ~*it runs on your machine but doesn't on mine*~ problem that almost all software engineers will inevitably encounter when they attempt to share their creations with the world (deployment). 

I won't go into the nitty-gritty details of how Docker works or why it's awesome - my goal with this article is to provide a recipe / demo of a `dockerized` React/Flask application and to highlight important concepts/gotchas while doing so. 

Before we begin, I want to highlight two major concepts that will help us `dockerize` our application and that is **images** and **containers**. 

## Images & Containers

The official definitions taken from the Docker Documentation:
> Docker images are the basis of containers. An Image is an ordered collection of root filesystem changes and the corresponding execution parameters for use within a container runtime. An image typically contains a union of layered filesystems stacked on top of each other. An image does not have state and it never changes.
>
> A container is a runtime instance of a docker image.
>A Docker container consists of:
> - A Docker image
> - An execution environment
> - A standard set of instructions
>
>The concept is borrowed from shipping containers, which define a standard to ship goods globally. Docker defines a standard to ship software.


An **image** is a read-only bundle of source code, libraries, tools, dependencies, assets, and whatever else an application needs to run. Images are defined in a `Dockerfile`.

A **container** is a running **image**. Often, an application will require numerous containers, with `x` number of applications running on `zed` number of ports. `docker-compose` allows us to manage all of this.

We will be writing both `Dockerfile` and `docker-compose.yml` files. The example source code used can be [found here](https://github.com/JamesDeLay/react-flask-docker). It's a super basic Flask app with a single endpoint and a `create-react-app` with a button that makes an API call.

## Docker for Dev: The Developer Experience 

The ideal developer experience inevitably varies from person to person. That being said, I think we can all agree a good development experience will include most of the following:

1. Quick reflection of changes:
   - Ideal situation: developer hits 'save' and changes are ready to be tested almost immediately
2. Ease of Debugging
   - During compile & runtime
   - Capturing application & container logs 
3. Portability
    - The code should run on most machines without tweaking
    - The development experience should come out-of-the-box along with the code

## Dockerize React

`Dockerfile.dev`
```Dockerfile
FROM node:alpine3.15

WORKDIR /app

COPY package*.json ./
RUN npm install
COPY . .

CMD ["npm", "start"]
```
Here's what this `Dockerfile` is doing:

1. Defining an new image from `node-alpine`
2. Creating a working directory called `app` to house our application
3. Copying only the `package.json && package-lock.json` files to the container from our local machine
4. Install `node_module` dependencies
5. Copy remainder of application to the working directory inside the container from our local machine
6. Specify what command to run within the container (`npm start`)

`docker-compose`
```yml
version: '3.8'
services:
  web:
    build:
      context: .
      dockerfile: Dockerfile.dev
    environment:
      - CHOKIDAR_USEPOLLING=true
    ports:
      - "3000:3000"
    volumes:
      - ./src:/app/src
      - /app/node_modules
```

Here's what this `docker-compose` file is doing:

1. Defining a service called `web`
2. Telling the build to use the `Dockerfile.dev` in the current directory (`context`)
3. Setting the `CHOKIDAR_USEPOLLING` env var to `true` to propagate events from the source machine's file system to the container's filesystem
4. Exposing port 3000 of the container and mapping it to port 3000 of the source machine
   1. This allows us to interact with the app at http://localhost:3000/
5. Mapping the `./src` directory to the `/app/src` directory inside the container 
6. Mounting the `/app/node_modules` filesystem as a volume. 
   - Volumes allow us to persist data generated by and used by Docker containers. In our scenario, we want Docker to persist the `node_modules` so we don't reinstall them every time the container rebuilds

<sub>Items 3,5, and 6 are what do the trick for hot-reloading</sub>


## Links & Resources

- `docker system prune --all --force` - when you hit Docker memory issues
  - ~ with great power comes great responsibility ~ 
- [Docker Documentation](https://docs.docker.com/)
- [Source code](https://github.com/JamesDeLay/react-flask-docker)